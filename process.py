"""
This project provides a demo of a confidential workload to find patients for clinical trials.
The confidential workload handles 2 events: one to trigger the data holders' data quality checks, one to trigger the query of participants candidates to a clinical trial based on specific criteria
"""

import logging
import time
import yaml
import os
import json
import duckdb
from datetime import datetime
import base64
import shutil

from dv_utils import default_settings, Client, ContractManager,SecretManager,audit_log,LogLevel


import pandas as pd

logger = logging.getLogger(__name__)


# let the log go to stdout, as it will be captured by the cage operator
logging.basicConfig(
    level=default_settings.log_level,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

# define an event processing function
def event_processor(evt: dict):
    """
    Process an incoming event
    Exception raised by this function are handled by the default event listener and reported in the logs.
    """
    
    logger.info(f"Processing event {evt}")

    # dispatch events according to their type
    evt_type =evt.get("type", "")
    if evt_type == "CHECK_DATA_QUALITY":
        # use the CHECK_DATA_QUALITY event processor dedicated function
        logger.info(f"Use the check data quality event processor")
        check_data_quality_contracts_event_processor(evt)
    elif(evt_type == "GET_NUMBER_OF_CANDIDATES"):
        logger.info(f"Use the get the number of candidates event processor")
        process_get_number_of_candidates_event(evt)
    else:
        generic_event_processor(evt)


def generic_event_processor(evt: dict):
    # push an audit log to reccord for an event that is not understood
    logger.info(f"Received an unhandled event {evt}")

def check_data_quality_contracts_event_processor(evt: dict):
    #audit logs are generated by the dv_utils sdk
    try:
        contractManager=ContractManager()
        test_results=contractManager.check_contracts_for_collaboration_space(default_settings.collaboration_space_id)

        #get data contracts from all data consumers
        data_contracts=contractManager.get_contracts_for_collaboration_space(default_settings.collaboration_space_id,Client.DATA_CONSUMER_COLLABORATOR_ROLE_VALUE)
        #Create in memory duckdb (encrypted memory on confidential computing)
        con = duckdb.connect(database=":memory:")
        
        #Add connector settings to duckdb con for all data contracts and export test results linked to the right client
        model_key="quality_checks"
        for data_contract in data_contracts:
            for test_result_descriptor_id in test_results:
                con = data_contract.connector.add_duck_db_connection(con)
                con.sql(data_contract.export_contract_to_sql_create_table(model_key))
                check_results=test_results[test_result_descriptor_id]
                for check_result in check_results:
                    description=check_result
                    timestamp=now = datetime.now()
                    formated_now = now.strftime('%Y-%m-%dT%H:%M:%SZ')
                    check_result_json=test_results[test_result_descriptor_id][check_result]
                    hasErrors=check_result_json["hasErrors"]
                    hasWarnings=check_result_json["hasWarnings"]
                    hasFailures=check_result_json["hasFailures"]
                    query="INSERT INTO "+model_key+" VALUES ('"+description+"','"+formated_now+"',"+str(hasErrors)+","+str(hasWarnings)+","+str(hasFailures)+",'"+str(json.dumps(check_result_json).replace("'","''"))+"')"
                    con.sql(query)
        data_contract.connector.export_signed_output_duckdb(model_key,default_settings.collaboration_space_id)
    except Exception as e:
        logger.error(e)

def process_get_number_of_candidates_event(evt: dict):
    """
    Get potential candidates â€“ Retrieve a report on the number of potential candidates to a clinical trial based on query criteria.
    """
    try:
        logger.info(f"---------------------------------------------------------")
        logger.info(f"|                    START PROCESSING                   |")
        logger.info(f"|                                                       |")
        start_time = time.time()
        logger.info(f"|    Start time:  {start_time} secs               |")
        logger.info(f"|                                                       |")
        audit_log(f"Start processing event: {evt.get('type', '')}.")

        #load parameters
        medical_problem= evt.get("medical_problem", "")
        medical_medication= evt.get("medical_medication", "")
        medical_vaccine= evt.get("medical_vaccine", "")

        logger.info(f"| 1. Get data contracts                                 |")
        logger.info(f"|                                                       |")

        #Connect in memory duckdb (encrypted memory on confidential computing)
        con = duckdb.connect(database=":memory:")

        collaboration_space_id=default_settings.collaboration_space_id
        contractManager=ContractManager()

        logger.info(f"| 2. Query patients from data sources                   |")
        logger.info(f"|                                                       |")
        data_contracts=contractManager.get_contracts_for_collaboration_space(collaboration_space_id)
        for data_contract in data_contracts:
            # Add DuckDB connection for the current data contract
            con = data_contract.connector.add_duck_db_connection(con)
            #hard coded patiens
            if data_contract.data_descriptor_id=="672116ef5d4301b25e5a7aa0":
                patient_source=data_contract.connector.get_duckdb_source("patients")
            else:
                demographic_source=data_contract.connector.get_duckdb_source("citizens")
        
        whereClause=""    
        if medical_problem!="":
            whereClause+=f"patients.medical_problem='{medical_problem}'"
        if medical_medication!="":
            if whereClause!="":
                whereClause+=" AND "
            whereClause+=f"patients.medical_medication='{medical_medication}'"
        if medical_vaccine!="":
            if whereClause!="":
                whereClause+=" AND "
            whereClause+=f"patients.medical_vaccine='{medical_vaccine}'"

        if whereClause!='':
            baseQuery=f"SELECT COUNT(*) as total from {demographic_source} as demographic, {patient_source} as patients WHERE demographic.national_id=patients.national_id AND "+whereClause
        else:
            baseQuery=f"SELECT COUNT(*) as total from {demographic_source} as demographic, {patient_source} as patients WHERE demographic.national_id=patients.national_id"
        
        print(baseQuery)
        #total candidates
        df = con.sql(baseQuery).df()
        totalCandidates=df['total'][0]
        
        #gender
        #male
        df = con.sql(baseQuery+ " AND demographic.gender='male'").df()
        totalGenderMale=df['total'][0]
        #female
        df = con.sql(baseQuery+ " AND demographic.gender='female'").df()
        totalGenderFemale=df['total'][0]

        #education_level
        #high_school
        df = con.sql(baseQuery+ " AND demographic.education_level='high_school'").df()
        totalEducationLevelHighSchool=df['total'][0]
        #college
        df = con.sql(baseQuery+ " AND demographic.education_level='college'").df()
        totalEducationLevelCollege=df['total'][0]
        #university
        df = con.sql(baseQuery+ " AND demographic.education_level='university'").df()
        totalEducationLevelUniversity=df['total'][0]


        #employment_status
        #unemployed
        df = con.sql(baseQuery+ " AND demographic.employment_status='unemployed'").df()
        totalEmploymentStatusUnemployed=df['total'][0]
        #employed
        df = con.sql(baseQuery+ " AND demographic.employment_status='employed'").df()
        totalEmploymentStatusEmployed=df['total'][0]
        #student
        df = con.sql(baseQuery+ " AND demographic.employment_status='student'").df()
        totalEmploymentStatusStudent=df['total'][0]
        #retired
        df = con.sql(baseQuery+ " AND demographic.employment_status='retired'").df()
        totalEmploymentStatusRetired=df['total'][0]

        logger.info(f"| 3. Export report                                      |")
        logger.info(f"|                                                       |")
        #get data contracts from all data consumers
        data_contracts=contractManager.get_contracts_for_collaboration_space(default_settings.collaboration_space_id,Client.DATA_CONSUMER_COLLABORATOR_ROLE_VALUE)
        export_model_key="candidates"
        for data_contract in data_contracts:
            con = data_contract.connector.add_duck_db_connection(con)
            con.sql(data_contract.export_contract_to_sql_create_table(export_model_key))
            query="INSERT INTO "+export_model_key+" VALUES ("+str(totalCandidates)+","+str(totalGenderMale)+","+str(totalGenderFemale)+","+str(totalEducationLevelHighSchool)+","+str(totalEducationLevelCollege)+","+str(totalEducationLevelUniversity)+","+str(totalEmploymentStatusUnemployed)+","+str(totalEmploymentStatusEmployed)+","+str(totalEmploymentStatusStudent)+","+str(totalEmploymentStatusRetired)+")"
            con.sql(query)
        data_contract.connector.export_signed_output_duckdb(export_model_key,default_settings.collaboration_space_id)
        audit_log(f"Candidates exported to: {data_contract.data_descriptor_id}.")
        logger.info(f"|                                                       |")
        execution_time=(time.time() - start_time)
        logger.info(f"|    Execution time:  {execution_time} secs           |")
        logger.info(f"|                                                       |")
        logger.info(f"--------------------------------------------------------")
    except Exception as e:
        logger.error(e)

    # output= ''' {
    # "candidates": '''+str(totalCandidates)+''',
    #     "gender": {
    #     "male":'''+str(totalGenderMale)+''',
    #     "female":'''+str(totalGenderFemale)+'''
    #     },
    #     "education_level": {
    #     "high_school":'''+str(totalEducationLevelHighSchool)+''',
    #     "college":'''+str(totalEducationLevelCollege)+''',
    #     "university":'''+str(totalEducationLevelUniversity)+'''
    #     },
    #     "employment_status":{
    #     "unemployed":'''+str(totalEmploymentStatusUnemployed)+''',
    #     "employed":'''+str(totalEmploymentStatusEmployed)+''',
    #     "student":'''+str(totalEmploymentStatusStudent)+''',
    #     "retired":'''+str(totalEmploymentStatusRetired)+'''
    #     }
    # } '''
   
